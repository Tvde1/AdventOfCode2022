using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AoC.SourceGenerators
{
    [Generator]
    public class PuzzleInputGenerator : IIncrementalGenerator
    {
        private static readonly DiagnosticDescriptor NoInputDescriptor = new(
            "AC0001",
            "No input",
            "No input file was found for {0} day {1}",
            "AoC",
            DiagnosticSeverity.Warning,
            true);

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var syntaxes = context.SyntaxProvider.CreateSyntaxProvider(MatchesPuzzle, ExtractPuzzle)
                .Collect();

            context.RegisterSourceOutput(syntaxes, GenerateCode);
        }

        private static bool MatchesPuzzle(
            SyntaxNode syntaxNode,
            CancellationToken cancellationToken)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
                return false;

            return classDeclaration.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString() == "Puzzle"));
        }

        private static (ClassDeclarationSyntax PuzzleClass, int Year, int Day) ExtractPuzzle(
            GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var classDec = context.Node as ClassDeclarationSyntax;

            var attr = classDec.AttributeLists.SelectMany(static y => y.Attributes).First(z => z.Name.ToString() == "Puzzle");

            var year = int.Parse(attr.ArgumentList!.Arguments[0].Expression.ToString());
            var day = int.Parse(attr.ArgumentList.Arguments[1].Expression.ToString());

            return (classDec, year, day);
        }

        private static void GenerateCode(SourceProductionContext context,
            ImmutableArray<(ClassDeclarationSyntax PuzzleClass, int Year, int Day)> enumerations)
        {
            var generatorPath = FilePath();

            generatorPath = Path.GetDirectoryName(generatorPath);

            foreach (var puzzle in enumerations)
            {
                if (context.CancellationToken.IsCancellationRequested)
                {
                    return;
                }
                
                var dayName = puzzle.PuzzleClass.Identifier.ToString();

                var fullPath = Path.Combine(generatorPath, $"../AoC.Puzzles/{puzzle.Year}/Input/{dayName}.txt");

                string rawInput = null;
                try
                {
                    rawInput = File.ReadAllText(fullPath);
                }
                catch
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        NoInputDescriptor,
                        puzzle.PuzzleClass.Identifier.GetLocation(),
                        puzzle.Year, puzzle.Day));
                }

                rawInput = rawInput?.Replace(@"""", @"""""");

                var propertyContent = rawInput == null ? "throw new NotImplementedException()" : $"@\"{rawInput}\"";

                var source = $@"// <auto-generated/>
using AoC.Common.Interfaces;
using AoC.Common.Attributes;
using System;

namespace {GetNamespace(puzzle.PuzzleClass).Name};

[PuzzleInput({puzzle.Year}, {puzzle.Day})]
public class {dayName}Input : IPuzzleInputProvider
{{
    // Text from {fullPath}
    public string GetRawInput() => {propertyContent};
}}";
                context.AddSource($"{dayName}Input.g.cs", source);
            }
        }

        private static string FilePath([CallerFilePath] string path = null) => path;

        private static BaseNamespaceDeclarationSyntax GetNamespace(BaseTypeDeclarationSyntax syntax)
        {
            var potentialNamespaceParent = syntax.Parent;

            while (potentialNamespaceParent != null)
            {
                if (potentialNamespaceParent is NamespaceDeclarationSyntax namespaceDeclarationSyntax)
                {
                    return namespaceDeclarationSyntax;
                }

                if (potentialNamespaceParent is FileScopedNamespaceDeclarationSyntax
                    fileScopedNamespaceDeclarationSyntax)
                {
                    return fileScopedNamespaceDeclarationSyntax;
                }

                potentialNamespaceParent = potentialNamespaceParent.Parent;
            }

            return null;
        }
    }
}