using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AoC.SourceGenerators
{
    [Generator]
    public class PuzzleInputGenerator : IIncrementalGenerator
    {
        private static readonly DiagnosticDescriptor NoInputDescriptor = new(
            "AC0001",
            "No input",
            "No input file was found for {0} day {1}",
            "AoC",
            DiagnosticSeverity.Warning,
            true);

        private static readonly DiagnosticDescriptor DuplicatePuzzleDescriptor = new(
            "AC0002",
            "Duplicate puzzle descriptor",
            "The puzzle descriptor of year {0} day {1} was found twice",
            "AoC",
            DiagnosticSeverity.Warning,
            true);

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var syntaxes = context.SyntaxProvider.CreateSyntaxProvider(MatchesPuzzle, ExtractPuzzle)
                .Collect();

            context.RegisterSourceOutput(syntaxes, GenerateCode);
        }

        private static bool MatchesPuzzle(
            SyntaxNode syntaxNode,
            CancellationToken cancellationToken)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
                return false;

            return classDeclaration.AttributeLists.Any(al => al.Attributes.Any(a => a.Name.ToString() == "Puzzle"));
        }

        private static (ClassDeclarationSyntax PuzzleClass, int Year, int Day) ExtractPuzzle(
            GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var classDec = context.Node as ClassDeclarationSyntax;

            var attr = classDec.AttributeLists.SelectMany(static y => y.Attributes).First(z => z.Name.ToString() == "Puzzle");

            var year = int.Parse(attr.ArgumentList!.Arguments[0].Expression.ToString());
            var day = int.Parse(attr.ArgumentList.Arguments[1].Expression.ToString());

            return (classDec, year, day);
        }

        private static void GenerateCode(SourceProductionContext context,
            ImmutableArray<(ClassDeclarationSyntax PuzzleClass, int Year, int Day)> enumerations)
        {
            var generatorPath = FilePath();

            generatorPath = Path.GetDirectoryName(generatorPath);

            var duplicatePuzzles = enumerations.GroupBy(x => new { x.Year, x.Day })
                .Where(x => x.Count() > 1)
                .ToList();

            if (duplicatePuzzles.Count != 0)
            {
                foreach(var duplicatePuzzlePair in duplicatePuzzles)
                {
                    context.CancellationToken.ThrowIfCancellationRequested();

                    foreach (var puzzle in duplicatePuzzlePair)
                    {
                        context.ReportDiagnostic(
                            Diagnostic.Create(DuplicatePuzzleDescriptor,
                            puzzle.PuzzleClass.GetLocation(),
                            puzzle.Year,
                            puzzle.Day));
                    }
                }

                return;
            }

            foreach (var puzzle in enumerations)
            {
                context.CancellationToken.ThrowIfCancellationRequested();

                var dayName = puzzle.Day.ToString("D2");
                var yearDayName = $"Y{puzzle.Year}D{dayName}";

                var fullPath = Path.Combine(generatorPath, "..", $"AoC.Puzzles.{puzzle.Year}", "Input", $"Day{dayName}.txt");

                string rawInput = null;
                try
                {
                    rawInput = File.ReadAllText(fullPath);
                }
                catch
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        NoInputDescriptor,
                        puzzle.PuzzleClass.Identifier.GetLocation(),
                        puzzle.Year, puzzle.Day));
                }

                rawInput = rawInput?.Replace(@"""", @"""""");

                var propertyContent = rawInput == null ? "null!" : $"@\"{rawInput}\"";

                var source = $@"// <auto-generated/>
using AoC.Common.Interfaces;
using AoC.Common.Attributes;
using System;

namespace {GetNamespace(puzzle.PuzzleClass).Name};

[PuzzleInput({puzzle.Year}, {puzzle.Day})]
public class {yearDayName}Input : IPuzzleInputProvider
{{
    // Text from {fullPath}.
    public static string GetRawInput() => {propertyContent};
}}";
                context.AddSource($"{yearDayName}Input.g.cs", source);
            }
        }

        private static string FilePath([CallerFilePath] string path = null) => path;

        private static BaseNamespaceDeclarationSyntax GetNamespace(BaseTypeDeclarationSyntax syntax)
        {
            var potentialNamespaceParent = syntax.Parent;

            while (potentialNamespaceParent != null)
            {
                if (potentialNamespaceParent is NamespaceDeclarationSyntax namespaceDeclarationSyntax)
                {
                    return namespaceDeclarationSyntax;
                }

                if (potentialNamespaceParent is FileScopedNamespaceDeclarationSyntax
                    fileScopedNamespaceDeclarationSyntax)
                {
                    return fileScopedNamespaceDeclarationSyntax;
                }

                potentialNamespaceParent = potentialNamespaceParent.Parent;
            }

            return null;
        }
    }
}